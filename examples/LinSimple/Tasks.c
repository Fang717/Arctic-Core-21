/*
* Configuration of module: Os (Tasks.c)
*
* Created by:
* Copyright:
*
* Configured for (MCU):    MPC5602B
*
* Module vendor:           ArcCore
* Generator version:       2.0.34
*
* Generated by Arctic Studio (http://arccore.com)
*/

#include "Os.h"

// #define USE_LDEBUG_PRINTF // Uncomment this to turn debug statements on.
#include "debug.h"
#include "Lin.h"
#include "LinIf.h"
#include "LinSM.h"
#include "PduR.h"
#include "Com.h"
#include "ComM.h"

uint16 Signal_Rx_1, Signal_Rx_2;
uint32  Word_1, Word_2;
uint32 Signal_Tx_2 = 0;
uint32 Signal_Tx_3 = 0;
uint8 Signal_Tx_1 = 0;

extern const Lin_ConfigType Lin_Config;
extern const LinIf_ConfigType LinIf_Config;
extern const LinSM_ConfigType LinSM_Config;
extern const Com_ConfigType ComConfiguration;


// Simple application which drives one Tx message and receives two messages
uint32 counter = 0;
void OsTask( void ) {



       while (1) {
          WaitEvent(EVENT_MASK_OsEvent);

          /* This is executed every 5 ms */
          LinIf_MainFunction();
          Com_MainFunctionRx();
          Com_MainFunctionTx();

          if ((counter % 100) == 0) {
        	  /* This is executed every 500 ms */
			  Com_ReceiveSignal(ComConf_ComSignal_Signal_Rx_1,(uint16 *) &Signal_Rx_1);
			  Com_ReceiveSignal(ComConf_ComSignal_Signal_Rx_2,(uint16 *) &Signal_Rx_2);
			  Com_ReceiveSignal(ComConf_ComSignal_Word_1, (uint32 *)&Word_1);
			  Com_ReceiveSignal(ComConf_ComSignal_Word_2, (uint32 *)&Word_2);
			  Signal_Tx_1++;
			  Signal_Tx_2--;
			  Signal_Tx_3 = Signal_Tx_2 ^ 0xFFFFFF ;

			  Com_SendSignal(ComConf_ComSignal_Signal_Tx_1, &Signal_Tx_1);
			  Com_SendSignal(ComConf_ComSignal_Signal_Tx_2, &Signal_Tx_2);
			  Com_SendSignal(ComConf_ComSignal_Signal_Tx_3, &Signal_Tx_3);
          }

          counter++;

          ClearEvent(EVENT_MASK_OsEvent);
       }

}

void Init( void ) {

    Com_IpduGroupVector groupVector;

    Signal_Tx_1 = Signal_Tx_2 = Signal_Tx_3 = 0;
    Lin_Init(&Lin_Config);
    LinIf_Init(&LinIf_Config);
    PduR_Init(&PduR_Config);
    LinSM_Init(&LinSM_Config);
    Com_Init(&ComConfiguration);
    ComM_Init(&ComM_Config);
    LinSM_RequestComMode(ComMConf_ComMChannel_ComMChannel1,COMM_FULL_COMMUNICATION);
    LinIf_MainFunction();
    LinSM_ScheduleRequest(ComMConf_ComMChannel_ComMChannel1,LinSMConf_LinSMSchedule_LinSMSchedule1);
    LinIf_MainFunction();

    Com_ClearIpduGroupVector(groupVector);
    Com_SetIpduGroup(groupVector, ComConf_ComIPduGroup_LIN, TRUE);
    Com_IpduGroupControl(groupVector, FALSE);
    TerminateTask();

}


void OsIdle( void ) {
    while(1){}
}

// Hooks
#define ERROR_LOG_SIZE 20

struct LogBad_s {
    uint32_t param1;
    uint32_t param2;
    uint32_t param3;
    TaskType taskId;
    OsServiceIdType serviceId;
    StatusType error;
};

void ErrorHook ( StatusType Error ) {

    TaskType task;
    static struct LogBad_s LogBad[ERROR_LOG_SIZE];
    static uint8_t ErrorCount = 0;
    GetTaskID(&task);
    OsServiceIdType service = OSErrorGetServiceId();

    LDEBUG_PRINTF("## ErrorHook err=%d\n",Error);

    /* Log the errors in a buffer for later review */
    LogBad[ErrorCount].param1 = os_error.param1;
    LogBad[ErrorCount].param2 = os_error.param2;
    LogBad[ErrorCount].param3 = os_error.param3;
    LogBad[ErrorCount].serviceId = service;
    LogBad[ErrorCount].taskId = task;
    LogBad[ErrorCount].error = Error;

    ErrorCount++;

    // Stall if buffer is full.
    while(ErrorCount >= ERROR_LOG_SIZE){}

}

void PostTaskHook ( void ) {
    TaskType task;
    GetTaskID(&task);
    LDEBUG_PRINTF("## PreTaskHook, taskid=%d\n",task);
}

void PreTaskHook ( void ) {
    TaskType task;
    GetTaskID(&task);
    LDEBUG_PRINTF("## PreTaskHook, taskid=%d\n",task);
}

void ShutdownHook ( StatusType Error ) {
    LDEBUG_PRINTF("## ShutdownHook\n");
    while(1){}
    (void) Error;
}

void StartupHook ( void ) {
    LDEBUG_PRINTF("## StartupHook\n");
}
